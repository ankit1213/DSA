================================================================================
APPROACH 1: BRUTE FORCE (O(n¬≤))
================================================================================

üí° CORE IDEA:
   Try every possible pair and check if their sum equals the target.

üîπ ALGORITHM STEPS:
   1. Loop through the array using index i
   2. For each i, loop again using index j = i + 1
   3. Check if nums[i] + nums[j] == target
   4. If true ‚Üí return [i, j]

üìä COMPLEXITY ANALYSIS:
   ‚Ä¢ Time Complexity:  O(n¬≤) ‚Üí nested loops iterate n √ó n times
   ‚Ä¢ Space Complexity: O(1) ‚Üí no extra data structures needed

‚ùå DISADVANTAGES FOR INTERVIEWS:
   ‚Ä¢ Too slow for large inputs (TLE on MAANG platforms)
   ‚Ä¢ Not scalable
   ‚Ä¢ Only acceptable for explaining the basic concept



================================================================================
APPROACH 2: HASH MAP APPROACH (O(n)) ‚≠ê OPTIMAL & RECOMMENDED
================================================================================

üí° CORE IDEA:
   For every number x, we need to find y such that:
   
   x + y = target
   y = target - x
   
   Instead of searching for y, we store numbers in a hash map and check if
   the complement (target - x) already exists.

üîπ ALGORITHM STEPS:
   1. Create an empty hash map (dictionary)
      ‚Ä¢ Key: number value
      ‚Ä¢ Value: index position

   2. Loop through the array (single pass):
      
      For each element nums[i]:
      
      a) Calculate complement = target - nums[i]
      
      b) If complement exists in the hash map:
         ‚Üí Return [map[complement], i]
      
      c) Otherwise:
         ‚Üí Store nums[i] ‚Üí i in the hash map
         ‚Üí Continue to next element

üìä COMPLEXITY ANALYSIS:
   ‚Ä¢ Time Complexity:  O(n) ‚Üí single pass through array
                             ‚Üí hash map lookup is O(1)
   ‚Ä¢ Space Complexity: O(n) ‚Üí hash map stores up to n elements

================================================================================
COMPARISON TABLE
================================================================================

| Approach  | Time Complexity | Space Complexity | Interview-Ready? |
|-----------|-----------------|------------------|------------------|
| Brute     | O(n¬≤)           | O(1)             | ‚ùå No (TLE)       |
| HashMap   | O(n)            | O(n)             | ‚úÖ Yes (OPTIMAL)  |

================================================================================
üî• INTERVIEW TIPS & BEST PRACTICES
================================================================================

‚úÖ DO THIS:
   1. Start by explaining the brute force approach (shows clarity)
   2. Identify its limitation (O(n¬≤) is too slow)
   3. Explain the optimization using hash map
   4. Code the optimal O(n) solution
   5. Walk through an example to validate

üìã EXAMPLE WALKTHROUGH:
   Input: nums = [2, 7, 11, 15], target = 9
   
   Step 1: i=0, nums[0]=2
           complement = 9-2 = 7
           7 not in map
           map = {2: 0}
   
   Step 2: i=1, nums[1]=7
           complement = 9-7 = 2
           2 exists in map at index 0 ‚úì
           Return [0, 1]

üí¨ WHAT TO SAY IN INTERVIEW:
   "I'll first explain the brute force approach for clarity, then optimize it
    using a hash map to achieve O(n) time complexity. This approach trades
    space for time, which is a common optimization technique in interviews."

================================================================================